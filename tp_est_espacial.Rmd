---
title: "Estadística espacial"
author: "Mateo W. Racca"
date: "`r format(Sys.time(), '%d/%m/%y')`"
output:
  html_document:
    toc: true
    toc_depth: 3
    toc_float: true
    theme: sandstone
    fig_caption: true
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


# Introducción


Este trabajo forma parte del módulo Estadística Espacial en el posgrado en Big Data e Inteligencia Territorial de FLACSO Argentina a cargo de Priscilla Minotti.


Se abordará un data set sobre puntos de elevación (originalmente medidos en pies pero convertidos a metros) de edificios en la ciudad de Nueva York con distintos métodos de interpolación espacial. 


Los datos originales están disponibles [acá](https://data.cityofnewyork.us/api/geospatial/szwg-xci6?method=export&format=Shapefile) mientras que la muestra con la que trabajamos junto con el proyecto del trabajo [acá](https://github.com/raccamateo/interpolacion_espacial).



## Paquetes


Cargamos los paquetes que vamos a utilizar:


```{r, message=FALSE, warning=FALSE}
library(tidyverse)
library(sf)
library(sp)
library(rgdal)
library(raster)
library(gstat)
library(osmdata)
library(leaflet)
library(tmap)
```


Ahora vamos a explicar paso por paso cómo es el procedimiento desde la carga de datos al procesamiento, las visualizaciones, los métodos de interpolación en sí y los resultados.


## Carga de datos


Cargamos el data set con la muestra de los puntos de elevación que vamos a usar para interpolar.


```{r}
elevaciones <- st_read("elevaciones_NY_muestra.shp") %>%
  st_as_sf() 
```


Para entender mejor los puntos de elevación vamos a usar *summary()*


```{r}
summary(elevaciones$elevacion)
```


Como vemos, el punto más de medición de altura de edificios mas bajo está elevado a 3.68 metros, en promedio la altura de los edificios es de 25.085 metros y la mediana es 22.315 metros. La altura máxima es de algo más de 430 metros.

## Visualizaciones básicas


Para entender mejor los datos vamos a graficar los puntos de elevación ubicados en el mapa. Para eso vamos a usar **tmap**. Lo configuramos.


```{r, message=FALSE}
tmap_mode("view")
```


Y ahora, graficamos los puntos con el mapa base:


```{r}
qtm(elevaciones)
```


Ahora vamos a ver específicamente cómo de distribuyen los puntos de elevación de nuestro data set y cual es su altura:


```{r}
ggplot() + 
  geom_sf(data = elevaciones, aes(color = elevacion)) + 
  scale_color_viridis_c(name = "Altura") + 
  ggtitle("Puntos de elevación: edificios en la ciudad de Nueva York", subtitle = "Altura expresada en metros") +
  theme_bw()
```


# Límites y Áreas de Interés


En este apartado vamos a ver tres métodos para definir el área de trabajo o de interés (*AOI*) que nos resulta útil para definir el área de análisis espacial a partir de nuestros datos.


## Bounding box (*bbox*)


Bounding box (o simplemente *bbox*) es un área definida por dos latitudes y dos longitudes.En este caso, usamos bbox que nos sirve para setear los límites (en forma de caja).


```{r}
elevaciones_bbox <- st_as_sfc(st_bbox(elevaciones))
```


## Buffer


Cuando usamos la función *st_buffer()*, ésta nos devuelve una geometría que representa todos los puntos cuya distancia es menor o igual a la distancia indicada. En este caso vamos a usar como distancia 2000 metros para crear un polígono usable para interpolar.


```{r}
elevaciones_buffer <- elevaciones %>% 
  st_buffer(dist= 2000) %>% 
  st_geometry() %>% 
  st_simplify() %>% 
  st_union()

elevaciones_buffer
```


## Polígono máximo convexo o convex hull


Convex hull es el polígono convexo más pequeño que incluye a todos los puntos incluidos en un data set. Vamos a calcular el polígono máximo convexo de nuestros puntos de elevación:


```{r}
elevaciones_convex_hull <- elevaciones %>% st_union()%>% st_convex_hull()
elevaciones_convex_hull
```


## Límites políticos y administrativos de la ciudad


```{r}
elevaciones_boundaries <- st_read("nybb.shp") %>%
  st_geometry() %>% 
  st_simplify() %>% 
  st_union()
```


## Límites en el mapa


Ahora vamos a ver cada tipo de límite en el mapa con los puntos de elevación:


```{r}
qtm(elevaciones) +
  #en rojo los bordes de la bounding box
  qtm(elevaciones_bbox, fill = NULL, borders="red") +
  #en azul los bordes de buffer
  qtm(elevaciones_buffer, fill = NULL, borders = "blue") +
  #en verde los bordes del poligono convexo
  qtm(elevaciones_convex_hull, fill = NULL, borders = "green") +
  #en negro los bordes de los límites políticos y administrativos
  qtm(elevaciones_boundaries, fill = NULL, borders = "black")
```


De ahora en adelante vamos a trabajar con los límites políticos y administrativos.


# Interpolación espacial

Vamos a desarrollar tres métodos de interpolación: Polígonos de Voronoi o Thiessen, Distancia Inversa Ponderada (de ahora en más *IDW*) y Kriging.


## Polígonos de Voronoi o Thiessen


Los puntos de elevación conocidos son utilizados como puntos generadores para dividir nuestra área de interés en tantos polígonos o teselas como puntos conocidos. El espacio interno de estos polígonos contiene todos los puntos cuya distancia al punto generador es menor que la distancia a cualquier otro punto externo. La división es a través de bisectores perpendiculares (líneas) que se forman al calcular las distancias entre puntos. 


```{r}
voronoi <- elevaciones %>% 
          st_geometry() %>%
          st_union() %>%
          st_voronoi() %>%
          st_collection_extract()%>%
          st_sfc(crs = st_crs(elevaciones)) %>% 
          st_sf() %>% 
          st_join(elevaciones) %>%
          st_intersection(elevaciones_boundaries)
```


```{r}
qtm(voronoi, fill = "elevacion", fill.palette = "-viridis")
```


Como podemos ver, se generaron tantos polígonos como puntos tiene nuestro dataset. El polígono con el edificio más alto está ubicado en la isla de Manhattan.


## Grilla de puntos y raster


Para utilizar los dos métodos de interpolación restantes necesitamos una grilla de puntos. Vamos a usar el dataset de puntos de elevación como base y la grilla estará contenida en una bounding box. Para eso:


```{r}
grilla_bbox <-  st_make_grid(elevaciones, cellsize = c(700, 700), what = "centers") %>%
  st_as_sf()
```


Nuestra grilla tiene 47300 puntos. Ahora vamos usar la función *st_intersection()* para quedarnos solo con los valores que se encuentran dentro de los límites de la ciudad.


```{r}
elevaciones_grilla <- grilla_bbox %>% st_intersection(elevaciones_boundaries)
```


La grilla resultante tiene 17160 puntos ubicados dentro de los límites de la ciudad. Vamos a usar este dataset para interpolar con IDW y Kriging.


## IDW

En la Distancia Inversa Ponderada cada punto tiene influencia local que disminuye con la distancia. El valor a predecir se calcula usando una combinación lineal ponderada de los vectores muestreados. A mayor proximidad al lugar a predecir, mayor peso de los puntos vecinos.


La potencia de la distancia inversa por defecto es uno (1). Vamos a calcular con esta configuración básica:


```{r}
elevaciones_idw <- gstat::idw(elevacion ~ 1, elevaciones, elevaciones_grilla)
```


Algunas estadísticas sobre la altura de las predicciones:


```{r}
summary(elevaciones_idw$var1.pred)
```


Como se puede observar, el valor máximo de las predicciones de altura de los edificios es de 178.847 metros. La altura promedio de los edificios es de casi 26 metros.

Graficamos con *ggplot*:
